from argparse import Namespace
import random
from typing import Callable, List, Tuple, Union

import numpy as np
from collections import defaultdict
from rdkit import Chem
from torch.utils.data.dataset import Dataset

from .scaler import StandardScaler
from chemprop.features import get_features_generator


class MolPairDatapoint:
    """A MolPairDatapoint contains two molecules and their associated features, context, and targets."""

    def __init__(self,
                 drug_smiles: str,
                 drug_fraction: float,
                 cmpd_smiles: str,
                 cmpd_fraction: float,
                 targets: List[float],
                 args: Namespace = None,
                 drug_feats: np.ndarray = None,
                 cmpd_feats: np.ndarray = None,
                 context: np.ndarray = None,
                 use_compound_names: bool = False):
        """
        Initializes a MolPairDatapoint, which contains a molecule pair.

        :param line: A list of strings generated by separating a line in a data CSV file by comma.
        :param args: Arguments.
        :param drug_feats: A numpy array containing additional features for molecule 1 (ex. Morgan fingerprint).
        :param cmpd_feats: A numpy array containing additional features for molecule 2 (ex. Morgan fingerprint).
        :param context: A numpy array containing additional features defining context (ex. cell line). THIS HAS BEEN REMOVED

        NOT SUPPORTED
        :param use_compound_names: Whether the data CSV includes the compound name on each line.
        """
        if args is not None:
            self.features_generator = args.features_generator
            self.args = args
        else:
            self.features_generator = self.args = None

        if (drug_feats is not None or cmpd_feats is not None) and self.features_generator is not None:
            raise ValueError('Currently cannot provide both loaded features and a features generator.')

        self.drug_feats = drug_feats
        self.cmpd_feats = cmpd_feats
        self.drug_fraction = float(drug_fraction)
        self.cmpd_fraction = float(cmpd_fraction)
        self.context = None #context
        
        

        if use_compound_names:
            raise NotImplementedError
        self.compound_name = None

        self.drug_smiles = drug_smiles  # str
        self.drug_mol = Chem.MolFromSmiles(self.drug_smiles)

        self.cmpd_smiles = cmpd_smiles  # str
        self.cmpd_mol = Chem.MolFromSmiles(self.cmpd_smiles)
        # Create targets
        self.targets = targets
        #print(targets)

        # Generate additional features if given a generator
        if self.features_generator is not None:
            self.drug_feats = []
            self.cmpd_feats = []

            for fg in self.features_generator:
                features_generator = get_features_generator(fg)
                if self.drug_mol is not None and self.drug_mol.GetNumHeavyAtoms() > 0:
                    self.drug_feats.extend(features_generator(self.drug_mol))
                if self.cmpd_mol is not None and self.cmpd_mol.GetNumHeavyAtoms() > 0:
                    self.cmpd_feats.extend(features_generator(self.cmpd_mol))

            self.drug_feats = np.array(self.drug_feats)
            self.cmpd_feats = np.array(self.cmpd_feats)

        # Fix nans in features
        if self.drug_feats is not None:
            replace_token = 0
            self.drug_feats = np.where(np.isnan(self.drug_feats), replace_token, self.drug_feats)
        if self.cmpd_feats is not None:
            replace_token = 0
            self.cmpd_feats = np.where(np.isnan(self.cmpd_feats), replace_token, self.cmpd_feats)
        if self.context is not None:
            replace_token = 0
            self.context = np.where(np.isnan(self.context), replace_token, self.context)

        
    def set_features(self, features: np.ndarray, mol: int):
        """
        Sets the features of the molecule.

        :param features: A 1-D numpy array of features for the molecule.
        :param mol: An int identifying which molecules the features correpond to. 0 for drug, 1 for compound, 2 for pair
        """
        assert (mol in [0,1,2])
        if mol == 0:
            self.drug_feats = features
        elif mol == 1:
            self.cmpd_feats = features
        else:
            self.context = features

    def num_tasks(self) -> int:
        """
        Returns the number of prediction tasks.

        :return: The number of tasks.
        """
        return len(self.targets)

    def set_targets(self, targets: List[float]):
        """
        Sets the targets of a molecule.

        :param targets: A list of floats containing the targets.
        """
        self.targets = targets


class MolPairDataset(Dataset):
    """A MolPairDataset contains a list of molecule pairs and their associated features, context, and targets."""

    def __init__(self, data: List[MolPairDatapoint]):
        """
        Initializes a MolPairDataset, which contains a list of MolPairDatapoints (i.e. a list of molecules).

        :param data: A list of MolPairDatapoints.
        """
        self.data = data
        self.args = self.data[0].args if len(self.data) > 0 else None
        self.drug_scaler, self.cmpd_scaler = None, None
        #print('TESTINGTESTINGTESTING')
        #print([d.targets for d in self.data])
        
    def compound_names(self) -> List[str]:
        """
        Returns the compound names associated with the molecule (if they exist).

        :return: A list of compound names or None if the dataset does not contain compound names.
        """
        if len(self.data) == 0 or self.data[0].compound_name is None:
            return None

        return [d.compound_name for d in self.data]

    def smiles(self) -> List[Tuple[str, str]]:
        """
        Returns the smiles strings associated with the molecules.

        :return: A list of smiles strings.
        """
        return [(d.drug_smiles, d.cmpd_smiles) for d in self.data]
    
    def fractions(self) -> List[Tuple[float, float]]:
        """
        Returns the fractions associated with the molecules.

        :return: A list of fractions (float).
        """
        return [(d.drug_fraction, d.cmpd_fraction) for d in self.data]

    def mols(self) -> List[Chem.Mol]:
        """
        Returns the RDKit molecules associated with the molecules.

        :return: A list of tuple of RDKit Mols.
        """
        return [(d.drug_mol, d.cmpd_mol) for d in self.data]

    def features(self) -> List[Tuple[np.ndarray, np.ndarray, np.ndarray]]:
        """
        Returns the features associated with each molecule (if they exist).

        :return: A list of 1D numpy arrays containing the features for each molecule or None if there are no features.
        """
        if len(self.data) == 0:
            return None

        return [(d.drug_feats, d.cmpd_feats, d.context) for d in self.data]

    def targets(self) -> List[List[float]]:
        """
        Returns the targets associated with each molecule.

        :return: A list of lists of floats containing the targets.
        """
        return [d.targets for d in self.data]

    def num_tasks(self) -> int:
        """
        Returns the number of prediction tasks.

        :return: The number of tasks.
        """
        return self.data[0].num_tasks() if len(self.data) > 0 else None

    def features_size(self) -> int:
        """
        Returns the size of the features array associated with each molecule.

        :return: The size of the features.
        """
        if len(self.data) == 0:
            return None

        drug_dim, cmpd_dim, context_dim = 0, 0, 0
        if self.data[0].drug_feats is not None:
            drug_dim = len(self.data[0].drug_feats)
        if self.data[0].cmpd_feats is not None:
            cmpd_dim = len(self.data[0].cmpd_feats)
        if self.data[0].context is not None:
            context_dim = len(self.data[0].context)
        return drug_dim + cmpd_dim + context_dim

    def shuffle(self, seed: int = None):
        """
        Shuffles the dataset.

        :param seed: Optional random seed.
        """
        if seed is not None:
            random.seed(seed)
        random.shuffle(self.data)

    def normalize_features(self, drug_scaler: StandardScaler = None, cmpd_scaler: StandardScaler = None, replace_nan_token: int = 0) -> StandardScaler:
        """
        Normalizes the features of the dataset using a StandardScaler (subtract mean, divide by standard deviation).

        If a scaler is provided, uses that scaler to perform the normalization. Otherwise fits a scaler to the
        features in the dataset and then performs the normalization.

        :param scaler: A fitted StandardScaler. Used if provided. Otherwise a StandardScaler is fit on
        this dataset and is then used.
        :param replace_nan_token: What to replace nans with.
        :return: A fitted StandardScaler. If a scaler is provided, this is the same scaler. Otherwise, this is
        a scaler fit on this dataset.
        """
        if len(self.data) == 0:
            return (None, None)

        if self.data[0].drug_feats is not None:
            if drug_scaler is not None:
                self.drug_scaler = drug_scaler
            elif self.drug_scaler is None:
                drug_feats = np.vstack([d.drug_feats for d in self.data])
                self.drug_scaler = StandardScaler(replace_nan_token=replace_nan_token)
                self.drug_scaler.fit(drug_feats)

            for d in self.data:
                d.set_features(self.drug_scaler.transform(d.drug_feats.reshape(1, -1))[0], 0)

        if self.data[0].cmpd_feats is not None:
            if cmpd_scaler is not None:
                self.cmpd_scaler = cmpd_scaler
            elif self.cmpd_scaler is None:
                cmpd_feats = np.vstack([d.cmpd_feats for d in self.data])
                self.cmpd_scaler = StandardScaler(replace_nan_token=replace_nan_token)
                self.cmpd_scaler.fit(cmpd_feats)

            for d in self.data:
                d.set_features(self.cmpd_scaler.transform(d.cmpd_feats.reshape(1, -1))[0], 1)

        return (self.drug_scaler, self.cmpd_scaler)

    def set_targets(self, targets: List[List[float]]):
        """
        Sets the targets for each molecule in the dataset. Assumes the targets are aligned with the datapoints.

        :param targets: A list of lists of floats containing targets for each molecule. This must be the
        same length as the underlying dataset.
        """
        assert len(self.data) == len(targets)
        for i in range(len(self.data)):
            self.data[i].set_targets(targets[i])

    def sort(self, key: Callable):
        """
        Sorts the dataset using the provided key.

        :param key: A function on a MoleculeDatapoint to determine the sorting order.
        """
        self.data.sort(key=key)

    def __len__(self) -> int:
        """
        Returns the length of the dataset (i.e. the number of molecules).

        :return: The length of the dataset.
        """
        return len(self.data)

    def __getitem__(self, item) -> Union[MolPairDatapoint, List[MolPairDatapoint]]:
        """
        Gets one or more MoleculeDatapoints via an index or slice.

        :param item: An index (int) or a slice object.
        :return: A MoleculeDatapoint if an int is provided or a list of MoleculeDatapoints if a slice is provided.
        """
        return self.data[item]


class ContrastMolPairDataset(MolPairDataset):
    """A ContrastMolPairDataset contains a list of molecule pairs and their associated features, context, and targets."""

    def __init__(self, data: List[MolPairDatapoint], sample_ratio: int, seed: int):
        """
        Initializes a ContrastMolPairDataset, which contains a list of MolPairDatapoints (i.e. a list of molecules).

        :param data: A list of MolPairDatapoints.
        :param sample_ratio: Number of negative examples to sample per positive example.
        :param seed: Random seed.
        """
        # Create lists of negative pairs indexed by drug and cmpd
        self.neg_data = [defaultdict(list),defaultdict(list)]
        for neg_pair in filter(lambda x: x.targets[0] == 0, data):
            self.neg_data[0][neg_pair.drug_smiles].append(neg_pair)
            self.neg_data[1][neg_pair.cmpd_smiles].append(neg_pair)

        # Only include those that have negative pairs to compare against
        self.pos_data = []
        for pos_pair in filter(lambda x: x.targets[0] == 1, data):
            if len(self.neg_data[1][pos_pair.cmpd_smiles]) > 0:
                self.pos_data.append( (pos_pair, 1) )
            if len(self.neg_data[0][pos_pair.drug_smiles]) > 0:
                self.pos_data.append( (pos_pair, 0) )
        # Need to shuffle order again to separate 0/1's and neg sample correlations.
        # External shuffle needed to make sure internal seeded shuffle is effective across epochs.
        self.shuffle(seed)

    # Self note: no need to impelment any more than the basics since it gets converted back to MolPairDataset anyways

    def shuffle(self, seed: int):
        """
        Shuffles the dataset.

        :param seed: Optional random seed.
        """
        random.seed(seed)
        random.shuffle(self.pos_data)
        for key in self.neg_data[0]:
            random.shuffle(self.neg_data[0][key])
        for key in self.neg_data[1]:
            random.shuffle(self.neg_data[1][key])

    def __len__(self) -> int:
        """
        Returns the length of the dataset (i.e. the number of molecules).

        :return: The length of the dataset.
        """
        return len(self.pos_data)

    def __getitem__(self, item) -> Union[MolPairDatapoint, List[MolPairDatapoint]]:
        """
        Gets one or more MoleculeDatapoints via an index or slice.

        :param item: An index (int) or a slice object.
        :return: A MoleculeDatapoint if an int is provided or a list of MoleculeDatapoints if a slice is provided.
        """
        retBatch = []
        iterate = self.pos_data[item]
        if type(item) == int:  # Handles case where you want to just query one point
            iterate = [iterate]

        for pos_pair, ind in iterate:  # Take slice of pos_data list.
            retBatch.append(pos_pair)
            query = pos_pair.cmpd_smiles if ind else pos_pair.drug_smiles

            neg_samples = self.neg_data[ind][query]
            retBatch.extend(neg_samples)
        return retBatch


def convert2contrast(dataset: MolPairDataset) -> ContrastMolPairDataset:
    if dataset.num_tasks() != 1:
        raise ValueError("Ambiguous conversion if more than one property.")
    args = dataset.args
    return ContrastMolPairDataset(dataset, args.sample_ratio, args.seed)
